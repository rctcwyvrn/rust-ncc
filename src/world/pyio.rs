use crate::parameters::quantity::Quantity;
use crate::parameters::{CharQuantities, Parameters, WorldParameters};
use crate::NVERTS;
use serde::{Deserialize, Serialize};
use std::fs::OpenOptions;
use std::path::PathBuf;

/// A combination of `parameters::CharQuants`, `parameters:WorldParameters`,
/// `parameters::PhysicalContactParameters`,`parameters::CoaParameters`.
/// and`parameters::Parameters`. However, some types are simplified (e.g.
/// types representing quantities are turned to `f32`). Meant for comparison
/// with output generated by Python model.
#[derive(Clone, Deserialize, Serialize, Default, Debug, PartialEq)]
pub struct Header {
    pub num_tsteps: usize,
    pub num_int_steps: usize,
    pub num_cells: usize,
    pub eta: f32,
    pub f: f32,
    pub l: f32,
    pub t: f32,
    pub l3d: f32,
    pub k_mem_on_vertex: f32,
    pub k_mem_off: f32,
    pub kgtp: f32,
    pub kdgtp: f32,
    pub close_zero_at: f32,
    pub close_one_at: f32,
    pub cil_mag: f32,
    pub coa_los_penalty: f32,
    pub coa_range: f32,
    pub coa_distrib_exp: f32,
    pub coa_mag: f32,
    pub vertex_eta: f32,
    pub cell_r: f32,
    pub rest_edge_len: f32,
    pub rest_area: f32,
    pub stiffness_edge: f32,
    pub const_protrusive: f32,
    pub const_retractive: f32,
    pub stiffness_cyto: f32,
    pub diffusion_rgtp: f32,
    /// Simplified from `parameters::Parameters`, where it is `RgtpDistribution`.
    pub init_rac: [f32; NVERTS],
    /// Simplified from `parameters::Parameters`, where it is `RgtpDistribution`.
    pub init_rho: [f32; NVERTS],
    pub halfmax_vertex_rgtp_act: f32,
    pub halfmax_vertex_rgtp_conc: f32,
    pub tot_rac: f32,
    pub tot_rho: f32,
    pub kgtp_rac: f32,
    pub kgtp_rac_auto: f32,
    pub kdgtp_rac: f32,
    pub kdgtp_rho_on_rac: f32,
    pub halfmax_tension_inhib: f32,
    pub tension_inhib: f32,
    pub kgtp_rho: f32,
    pub kgtp_rho_auto: f32,
    pub kdgtp_rho: f32,
    pub kdgtp_rac_on_rho: f32,
    pub randomization: bool,
    pub rand_avg_t: f32,
    pub rand_std_t: f32,
    pub rand_mag: f32,
    pub num_rand_vs: u32,
    pub total_rgtp: f32,
}

/// Stores data generated in intermediate integration steps.
#[derive(Clone, Deserialize, Serialize, Default, Debug, PartialEq)]
pub struct IntStepData {
    pub poly: Vec<[f32; 2]>,
    pub rac_acts: [f32; NVERTS],
    pub rac_inacts: [f32; NVERTS],
    pub rho_acts: [f32; NVERTS],
    pub rho_inacts: [f32; NVERTS],
    pub sum_forces: Vec<[f32; 2]>,
    pub uivs: Vec<[f32; 2]>,
    pub kgtps_rac: [f32; NVERTS],
    pub kdgtps_rac: [f32; NVERTS],
    pub kgtps_rho: [f32; NVERTS],
    pub kdgtps_rho: [f32; NVERTS],
    pub rgtp_forces: Vec<[f32; 2]>,
    pub edge_forces: Vec<[f32; 2]>,
    pub cyto_forces: Vec<[f32; 2]>,
    pub conc_rac_acts: [f32; NVERTS],
    pub x_cils: [f32; NVERTS],
    pub x_coas: [f32; NVERTS],
    pub rac_act_net_fluxes: [f32; NVERTS],
    pub edge_strains: [f32; NVERTS],
    pub poly_area: f32,
}

#[derive(Clone, Deserialize, Serialize, Default, Debug, PartialEq)]
pub struct IntSteps {
    int_steps: Vec<IntStepData>,
}

#[derive(Clone, Deserialize, Serialize, Default, Debug, PartialEq)]
pub struct CellStates {
    cells: Vec<IntSteps>,
}

impl CellStates {
    pub fn flatten(&self) -> Vec<Vec<IntStepData>> {
        let mut r = vec![];
        for ix in 0..self.cells.len() {
            let mut int_steps = vec![];
            for int_step in &self.cells[ix].int_steps {
                int_steps.push(int_step.clone());
            }
            r.push(int_steps.clone());
        }
        r
    }
}
#[derive(Clone, Deserialize, Serialize, Default, Debug, PartialEq)]
pub struct Data {
    header: Header,
    pub tsteps: Vec<Vec<Vec<IntStepData>>>,
}

#[derive(Default)]
pub struct Writer {
    file_path: PathBuf,
    pub data: Data,
    temp_int_steps: IntSteps,
    temp_cell_states: CellStates,
    int_steps_saved: bool,
    cell_states_saved: bool,
    pub num_tsteps: usize,
    pub num_int_steps: usize,
    pub num_cells: usize,
    pub finished: bool,
}

impl Writer {
    pub fn init(
        &mut self,
        num_tsteps: usize,
        num_int_steps: usize,
        num_cells: usize,
        cil_mag: u32,
        coa_mag: u32,
    ) -> Writer {
        let file_dir =
            String::from("B:\\rust-ncc\\model-comparison\\rust-out\\");
        let file_path = PathBuf::from(format!(
            "{}out_euler_T={}_E={}_NC={}_CIL={}_COA={}.dat",
            file_dir, num_tsteps, num_int_steps, num_cells, cil_mag, coa_mag
        ));
        Writer {
            num_tsteps,
            num_int_steps,
            num_cells,
            file_path,
            data: Data::default(),
            temp_int_steps: Default::default(),
            temp_cell_states: Default::default(),
            int_steps_saved: false,
            cell_states_saved: false,
            finished: false,
        }
    }

    pub fn save_int_step(&mut self, data: IntStepData) {
        self.int_steps_saved = false;
        self.temp_int_steps.int_steps.push(data);
        if self.temp_int_steps.int_steps.len() == self.num_int_steps {
            self.save_cell_state();
            self.int_steps_saved = true;
        }
    }

    fn save_cell_state(&mut self) {
        self.cell_states_saved = false;
        self.temp_cell_states
            .cells
            .push(self.temp_int_steps.clone());
        self.temp_int_steps = IntSteps::default();
        if self.temp_cell_states.cells.len() == self.num_cells {
            self.save_tstep();
            self.cell_states_saved = true;
        }
    }

    fn save_tstep(&mut self) {
        self.data.tsteps.push(self.temp_cell_states.flatten());
        self.temp_cell_states = CellStates::default();
        if self.data.tsteps.len() == self.num_tsteps {
            self.finish();
        }
    }

    pub fn finish(&mut self) {
        let mut f = OpenOptions::new()
            .create(true)
            .truncate(true)
            .write(true)
            .open(&self.file_path)
            .unwrap();

        serde_json::to_writer(&mut f, &self.data).unwrap();
        self.finished = true;
    }

    pub fn save_header(
        &mut self,
        char_quants: &CharQuantities,
        world_params: &WorldParameters,
        params: &Parameters,
    ) {
        self.data.header = Header {
            num_tsteps: self.num_tsteps,
            num_int_steps: self.num_int_steps,
            num_cells: self.num_cells,
            eta: char_quants.eta.number(),
            f: char_quants.f.number(),
            l: char_quants.l.number(),
            t: char_quants.t.number(),
            l3d: char_quants.l3d.number(),
            k_mem_off: params.k_mem_off,
            k_mem_on_vertex: params.k_mem_on_vertex,
            kgtp: char_quants.kgtp.number(),
            kdgtp: char_quants.kdgtp.number(),
            close_zero_at: world_params.interactions.phys_contact.range.zero_at,
            close_one_at: world_params.interactions.phys_contact.range.one_at,
            cil_mag: world_params.interactions.phys_contact.cil_mag,
            coa_los_penalty: world_params
                .interactions
                .coa
                .as_ref()
                .map_or_else(|| 0.0, |coa_gen| coa_gen.los_penalty),
            coa_range: world_params
                .interactions
                .coa
                .as_ref()
                .map_or_else(|| 0.0, |coa_gen| coa_gen.range),
            coa_distrib_exp: world_params
                .interactions
                .coa
                .as_ref()
                .map_or_else(|| 0.0, |coa_gen| coa_gen.distrib_exp),
            coa_mag: world_params
                .interactions
                .coa
                .as_ref()
                .map_or_else(|| 0.0, |coa_gen| coa_gen.mag),
            vertex_eta: world_params.vertex_eta,
            cell_r: params.cell_r,
            rest_edge_len: params.rest_edge_len,
            rest_area: params.rest_area,
            stiffness_edge: params.stiffness_edge,
            const_protrusive: params.const_protrusive,
            const_retractive: params.const_retractive,
            stiffness_cyto: params.stiffness_cyto,
            diffusion_rgtp: params.diffusion_rgtp,
            init_rac: params.init_rac.active,
            init_rho: params.init_rho.active,
            halfmax_vertex_rgtp_act: params.halfmax_vertex_rgtp_act,
            halfmax_vertex_rgtp_conc: params.halfmax_vertex_rgtp_conc,
            tot_rac: params.tot_rac,
            tot_rho: params.tot_rho,
            kgtp_rac: params.kgtp_rac,
            kgtp_rac_auto: params.kgtp_rac_auto,
            kdgtp_rac: params.kdgtp_rac,
            kdgtp_rho_on_rac: params.kdgtp_rho_on_rac,
            halfmax_tension_inhib: params.halfmax_tension_inhib,
            tension_inhib: params.tension_inhib,
            kgtp_rho: params.kgtp_rho,
            kgtp_rho_auto: params.kgtp_rho_auto,
            kdgtp_rho: params.kdgtp_rho,
            kdgtp_rac_on_rho: params.kdgtp_rac_on_rho,
            randomization: false,
            rand_avg_t: params.rand_avg_t,
            rand_std_t: params.rand_std_t,
            rand_mag: params.rand_mag,
            num_rand_vs: params.num_rand_vs,
            total_rgtp: params.total_rgtp,
        };
    }
}
